#!/usr/bin/perl -w
# PMSMacros.pm - support routines to support Properties and Macros.

# Copyright (c) 2016 Bob Upshaw.  This software is covered under the Open Source MIT License 

package PMSMacros;

use File::Basename;
#use lib 'PMSPerlModules';
use PMSConstants;
use PMSLogging;
require PMSUtil;


use strict;
use sigtrap;
use warnings;

my %calendar;						# See ProcessCalendarPropertyLine() for more info.
#	%calendar is a hash that stores details of every OW event we expect to process for
#	the current year. The properties file contains a text version of the %calendar hash
#	broken down to one line per OW event. See ProcessCalendarPropertyLine() for details
#	on how the calendar hash is specified in the property file.
#	The %calendar hash contains a number of elements for each OW event. The keys into this
#	hash look like this:
#		%calendar{n-detail}
#	where
#		n is the "race number" (aka event number), which is the number of the event
#			in the property file, starting with 1.
#		detail is a text string naming a specific detail of the event, e.g. Date or CAT.
#	For each event here is a list of details we have for that event (note that this list
#	may be different for different versions of the calendar line in the property file. See
#	ProcessCalendarPropertyLine() for more details.)
#		FileName - the partial path to the result that we process for this event
#		CAT - the suit category of this event
#		Date - the date that this event is swum
#		Distance - the distance of this event, in miles
#		EventName - the name of this event (e.g. "Lake Berryessa 1 Mile")
#		UniqueID - the unique id of this event to distinguish it from all other events 
#			tracked by our OW points system.
#		Keywords - a list of keywords to help us confirm that a file name matches the event.
#		Link - a URL pointed to a description of this OW event.
#	In addition, there are details that may be generated by OW Points for an event and
#		stored in this hash:
#		HRLink - a link to the human readable results generated while processing points.
#	In addition, the following hash entries exist for each event:
#		%calendar{n} = FileName
#xxxxxx		%calendar{FileName} = n
#	where 'n' is the race number.


my @categories;						# $categories[n] = %catHash()
# Note that @categories will start with index 0, where 0 is the made-up category "pre-trout" and 
#	not an actual category to be displayed. It's used so we can count the number of swimmers
#	who have not yet achieved a real category.
# Each element of the above array is a "%catHash", which looks like this:
#	$catHash{"name"} - the name of a category, e.g. "Trout" or "Whale"
#	$catHash{"minCount"} - the minimum number of swims a swimmer must swim to be in this
#		category. For example, a "Trout" may be 5, and a Whale may be 100.
#	$catHash{"maxCount"} - the maximum number of swims a swimmer must swim to be in this 
#		category. Any more swims and they are moved into the next category.
#	$catHash{year-swimmers} - number of swimmers in this category cumulative from the start year
#		up to and including this 'year'.  For example, if 
#			- the starting year is 2018 and
#			- $categories[1]{2018-swimmers} is 85
#				in 2019 11 category[1] swimmers advanced to category[2]
#				in 2019 5 swimmers advanced to category[1]
#			- $categories[1]{2019-swimmers} is 79 (85 - 11 + 5)
#	$catHash{"patch"} - the name of the image file holding an image of the patch for this category,
#		e.g. "trout.jpg" or "Manatee.png"
	


my $templateName = "";				# Global varialbe used to hold the name of the template file being processed

sub SetTemplateName( $ ) {
	$templateName = $_[0];
}

sub GetTemplateName() {
	return $templateName;
}

# Read the properties.txt file and set the necessary properties by setting name/values in 
# the %macros hash which is accessed by the reference returned by PMSStruct::GetMacrosRef().  For example,
# after the property file is processed by this routine, and if the macro "TotalMilesSwum" is set in the 
# properties file, then it's value is retrieved by 
#		my $myTotalMilesSwum = PMSStruct::GetMacrosRef()->{"TotalMilesSwum"};
# Furthermore, any macro can be created/changed by something like this:
#		PMSStruct::GetMacrosRef()->{"TotalMilesSwum"}++;
#
# The main use of these macros is to allow us to use "template" files to generate our output.  For example,
# here is some example HTML in a template file:
#			    		<a href="" onclick="return ponclick('{ListToPlaceID}-total')">
#			    			Total Distance: {TotalMilesSwum} Miles, Total Time: {TotalTimeSwum}, 
#			    			Average 1 Mile time: {AverageOneMileTime}</a>
# Note that during template processing every occurance of a {xxx} is replaced with the value of the
# macro 'xxx'.
#
# PASSED:
#	$propertiesDir - the full path name of the directory holding the property file
#	$simplePropFileName - the (simple) file name of the property file (usually 'properties.txt')
#		NOTE:  the two together make a full path name to the property file, so it's not necessary
#		that $simplePropFileName is a simple name as long as "$propertiesDir . $simplePropFileName" is
#		a valid full path to the property file.
#	$yearBeingProcessed - the year we think we're processing (taken from the date of
#		processing or passed program parameter or some other application-dependent method.)
#		Any attempt to change the macro with the same name ('YearBeingProcessed')
#		will throw a non-fatal error and then be ignored.
#
# NOTES:
#	A line in this file looks like one of the following:
#			name
#		(in this case the macro named 'name' is set to the empty string.  Leading and trailing whitespace
#		 is removed from the name)
#			name    value
#		(in this case the macro named 'name' is asigned the value 'value'.  Leading and trailing whitespace
#		 is removed from the name and from the value)
# 	or
#			name    value;  \
#				more value;  \
#				more value;
#		(in this case the macro named 'name' is asigned the value 'value;more value;more value;'.  
#		 Leading and trailing whitespace is removed from the name and from the values)
#
sub GetProperties( $$$ ) {
	my ($propertiesDir, $simplePropFileName, $yearBeingProcessed) = @_;
	my $propFileFD;
	my $propFileName = $propertiesDir . "/" . $simplePropFileName;
	SetTemplateName( $propFileName );
	my $lineNum = 0;
	my $processingCalendar = 0;		# set to 1 when processing a ">calendar....>endcalendar" block
	my $processingCategories = 0;	# set to 1 when processing a ">categories...>endcategories" block
	my $processingSkip = 0;			# set to 1 when processing a ">skip...>endskip" block
	open( $propFileFD, "< $propFileName" ) || die( "Can't open $propFileName: $!" );
	while( my $line = <$propFileFD> ) {
		my $value = "";
		$lineNum++;
		chomp( $line );
		$line =~ s/\s*#.*$//;		# remove optional spaces followed by comment
		$line =~ s/^\s+|\s+$//g;			# remove leading and trailing space

		# if we're processing a >skip block then all we want to find is an >endskip ignoring
		# everything else.
		if( $processingSkip ) {
			if( $line =~ m/^>endskip$/ ) {
				$processingSkip = 0;
			}
			next;
		}

		# handle a continuation line
		while( $line =~ m/\\$/ ) {
			$line =~ s/\s*\\$//;		# remove (optional) whitespace followed by continuation char
			# special case:  if the entire line is a single word add a space so we find the 'name', e.g. the lines
			# look like this:
			#    name \
			#		value...
			if( ! ($line =~ m/\s/) ) {
				$line .= " ";
			}
			my $nextLine;
			last if( ! ($nextLine = <$propFileFD>) );		# get the next line
			$lineNum++;
			chomp( $nextLine );
			$nextLine =~ s/\s*#.*$//;		# remove optional spaces followed by comment
			$nextLine =~ s/^\s+|\s+$//g;			# remove leading and trailing space
			$line .= $nextLine;
		}

		next if( $line eq "" );		# if we now have an empty line then get next line
		my $macroName = $line;
		$macroName =~ s/\s.*$//;	# remove all chars from first space char until eol
		if( ($macroName =~ m/^>/) || $processingCalendar || $processingCategories ) {
			# found a non macro definition (synonym, etc of the form ">....")
			$macroName = lc( $macroName );
			if( $macroName eq ">skip" ) {
				$processingSkip = 1;
				next;
			} elsif( $macroName eq ">calendar" ) {
				$processingCalendar = 1;
				next;
			} elsif( $macroName eq ">endcalendar" ) {
	#			ProcessCalendarPropertyLine($line, $yearBeingProcessed);
				$processingCalendar = 0;
				next;
			} elsif( $processingCalendar ) {
				ProcessCalendarPropertyLine($line, $yearBeingProcessed);
				next;
			} elsif( $macroName eq ">categories" ) {
				$processingCategories = 1;
				next;
			} elsif( $macroName eq ">endcategories" ) {
				$processingCategories = 0;
				next;
			} elsif( $processingCategories ) {
				ProcessCategoriesLine( $line );
				next;
			} elsif( $macroName eq ">include" ) {
				$line = ProcessMacros( $line, $lineNum );		# allow include path to contain other macros
				ProcessInclude( $propertiesDir, $line, $yearBeingProcessed );
				next;
			} elsif( $macroName eq ">endoffile" ) {
				last;
			}
			# normal one line ">..." line:
			$line =~ s/^\S+\s+//;  # remove >xxx part (and following spaces)
			my $lineLC = lc( $line );
			my $name1 = $lineLC;
			$name1 =~ s/\s.*$//;	# first word following '>xxx   ' part (no imbedded spaces)
			my $name2 = $lineLC;
			$name2 =~ s/^[^\s]+\s+//;	# second word and all that follows
			my $count = 1;
			if( $macroName eq ">last" ) {
				# last name synonyms NOT USED
				print( "!!! ERROR: Illegal '>' property: '$line' (>last not supported)\n");
			} elsif( $macroName eq ">first") {
				# first name synonyms NOT USED
				print( "!!! ERROR: Illegal '>' property: '$line' (>first not supported)\n");
			} elsif( $macroName eq ">team" ) {
				# team name synonyms NOT USED
				print( "!!! ERROR: Illegal '>' property: '$line' (>team not supported)\n");
			} elsif( $macroName eq ">key" ) {
				# key synonyms
				print( "!!! ERROR: Illegal '>' property: '$line' (>key not supported)\n");
			} elsif( $macroName eq ">last,first" ) {
				# syntax:    >last,first   last,first   >	 Last,First[,Extra]
				# where
				#	>last,first is in any case
				#	last,first (name1) is in any case, can contain spaces, only one allowed (use last one seen), no commas, double quotes.
				#	Last,First[,Extra] (name2) is in correct case, and can contain an optional ",Extra"
				#	Any time we see a result and we extract the last,first (and extra if there) for the swimmer,
				#	we see if it matches name1 (case-
				#	insensitive).  If it does, we will use name2 (in Canonical form)
				$name1 = lc($line);
				$name1 =~ s/\s*>.*$//;		# remove second name
				$name2 = $line;
				$name2 =~ s/^.*>\s*//;	# remove first name and leading spaces, left with second name which may have a ,Extra
				PMSStruct::GetSynonymFirstLastNameRef()->{$name1} = $name2;
			} elsif( $macroName eq ">regnum" ) {
				# >regnum badRegNum goodRegNum
				# Reg Number synomyms, e.g.
				# >regnum 384D-D414R 384P-0414R
				my $name1 = uc($lineLC);
				$name1 =~ s/\s+[^\s]+$//;
				my $name2 = uc($lineLC);
				$name2 =~ s/^.+\s//;
				PMSStruct::GetSynonymRegNumRef()->{$name1} = $name2;
				
			} elsif( $macroName eq ">regnumname" ) {
				# >regnumName xxxxxx > last,first,middle	> yyyyyyy		where ,middle is optional
				# 	$lineLC = 'xxxxxx > last,first,middle	> yyyyyyy'  ALL LOWER CASE!
				# 	'xxxxxx' can be anything but no trailing spaces (spaces prior to '>' will be removed); no >
				# 	'yyyyyyy' does not contain spaces or >  WILL CONVERT TO UPPER CASE!
				# 	'last, first, middle can contain spaces; no commas, no >.  Must be name in PMS db
				$lineLC =~ m/^([^>]+)>([^>]+)>\s*(\S+)/;
				my $reg1 = $1;		# 'xxxxxx    '
				my $fullName = $2;	# '    last,first,middle     ' ALL LOWER CASE
				my $reg3 = uc($3);		# 'yyyyyyy'
				# clean it up
				$reg1 =~ s/\s*$//;			# 'xxxxxx'
				$fullName =~ s/^\s*//;		# remove leading spaces 'last,first,middle     ' or 'last,first     '
				$fullName =~ s/\s*$//;		# remove trailing spaces 'last,first,middle' or 'last,first'
				PMSStruct::GetSynonymRegNumRef()->{"$reg1>$fullName"} = $reg3;
			} elsif( $macroName eq ">error" ) {
				$lineLC =~ s/\s*//g;			# remove all whitespace
				#### do we need this?:  $PMSConstants::ErrorsToIgnore .= "|||$lineLC|||";			
			} else {
				print( "!!! ERROR: Illegal '>' property: '$line'\n");
			}
		} else {
			# we have a macro, but there are special cases where we IGNORE macros defined by property files:
			# Don't set the "YearBeingProcessed" macro to the value in the property file since it's required
			# that the yearBeingProcessed be known prior to reading the property file.
			if( $macroName eq "YearBeingProcessed" ) {
				print( "!!! (non-fatal) ERROR: It is illegal to attempt to set YearBeingProcessed " .
					"in a property file. Fix this line: '$line'\n");
				next;
			}
			# this is executed only if a non-empty or empty value is assigned to the property in the property file.
			if( $macroName eq $line ) {
				# empty value
				PMSStruct::GetMacrosRef()->{$macroName} = "";
			} else {
				# non-empty value
				$line = ProcessMacros( $line, $lineNum );		# allow values in property file to contain other macros
				$value = $line;
				$value =~ s/^[^\s]+\s+//;
				PMSStruct::GetMacrosRef()->{$macroName} = $value;
			}
			#PMSLogging::DumpNote( "", "", "macroname='$macroName', value='$value'" );
		}
	}
} # end of GetProperties





# ProcessInclude - This function is used to process an >include directive in a template file
#	Such a line is of the form ">include Historical/2015/2015-properties.txt"
# 
#
# PASSED:
#	$propertiesDir - the directory holding the property file that contains the >include directive.
#	$simplePropFileName - the file name of the property file.  It's basically the string following the
#		>include phrase.  Thus it could be a simple name, a partial path (as above), or a full path.
#	$yearBeingProcessed - 
#
# If the $simplePropFileName is a simple name or a partial path name then the $propertiesDir is prepended to
#	form the full path name of the property file to be included.
#
#		--- See GetProperties()
#	
sub ProcessInclude( $$$ ) {
	my $propertiesDir = $_[0];
	my $simplePropFileName = $_[1];
	my $yearBeingProcessed = $_[2];
	$simplePropFileName =~ s/^[^\s]+\s+//;		# get rid of the '>include   ' part
	my $value = $simplePropFileName;
	# is the "simple" name really a full path name?
	if( $value =~ m,^/, ) {
		# YES!  use it by itself
	} else {
		# NO! construct a full path name
		$value = $propertiesDir . "/" . $simplePropFileName;
	}
	# now, divide into full path directory and simple file name
	my $propertiesDir2 = dirname($value);
	my $propertiesFileName = basename($value);
	
	GetProperties( $propertiesDir2, $propertiesFileName, $yearBeingProcessed );
} # end of ProcessInclude()



# ProcessCalendarPropertyLine - process one line from the sequence of lines between 
#		the >calendar and >endcalendar directivies in a property file.
#
# NOTE: THERE ARE 2 VERSIONS OF CALENDAR LINE THIS ROUTINE CAN HANDLE
#
# PASSED:
#	$line - a calendar line which is a physical line used to begin (or completely contain, 
#		depending on the version) one specific OW event. Details below.
#	$yearBeingProcessed - the OW year being processed (e.g. "2024")
#
# RETURNED:
#	n/a
#
# NOTES:
# 	The order of the races is implied by the order of lines in the property file, not the
#	date of the races.  This is due to the fact that there are often multiple races on the
#	same day and we want the order of events in the generated Accumulated Points page to
#	be deterministic.
#
# DETAILS:
#	A $line is made up of a sequence of fields, where each field looks like this:
#		->	X	->
#		where 'X' is a piece of data describing a single OW event.
#	There are currently two versions of $line recognized, with variations described below.
#	Here is a list of all possible fields and in which versions they exist:
#	- file name [versions 1 and 2, with variations (see below)]
#		the file name of the file holding the results of this event relative to the
#		directory given by the InputResultsDir macro defined in the property file.
#		NOTE: See Variations below.
#	- the category of the event (1 or 2)
#	- the date of the event in the form yyyy-mm-dd. (mm and/or dd can be a single digit)
#	- the distance of the event in miles. 0 if NO DETAILS.
#	- the event name known to the system, e.g.  "Spring Lake 1 Mile".  The name
#		presented to the human is "2014 Spring Lake 1 Mile" where the "2014" comes from the date.
#		If the event name contains a distance (e.g. "1 Mile" in this example) it should be last.  E.g.
#		"Spring Lake 1 Mile" is OK, but "Spring Lake 1 Mile Swim" could be a problem when displaying
#		"meet names" in AGSOTY.
#	- the UNIQUE event id.  This Id is used to distinguish this event from all other events
#		ever seen by this program for all years covered by this program.  Note that a cat 1 event
#		and a cat2 event will have the same unique id if they are the same event.
#		This field must be supplied (non-empty) but will be ignored if NO DETAILS.
#	- the link is a link to info about this race. Probably only valid for the year of the race.
#		This field must be supplied (non-empty) but will be ignored if NO DETAILS.
#	- keywords: this is an OPTIONAL field and is used to support the UPLOAD web program. If present, it is a list of 1 or
#		more words of the form
#			xxx, yyy, zzz, ..., aaa
#		where each string of words is a word likely found in the name of the file containing the results. The file name is
#		NOT required to contain any/all of these words, but if, during an Upload, a file is specified to the Upload UI and
#		that filename contains one of the words belonging to a different file then Upload will complain.  Example, the keywords
#		for Spring Lake would be "Spring". If, during an Upload of some Berryessa results the file
#		being uploaded has a name containing the word "Spring" (case insensitive) then Upload will complain.
#
#
##### VERSION 1: a $line expressed in the Version 1 format looks like this:
#		[version  ->]	file name	->	cat ->   yyyy-mm-dd	->	distance (miles)	-> human readable swim name  ->  Unique Event Id	-> keywords
#	e.g.
#		2014 Spring Lake 1 Mile=CAT1.csv	->	1	->	2014-06-23	->	1	-> 2014 Spring Lake 1 Mile  ->  1	->	Spring
#	or
#		1	2014 Spring Lake 1 Mile=CAT1.csv	->	1	->	2014-06-23	->	1	-> 2014 Spring Lake 1 Mile  ->  1	->	Spring
#	where [version   ->] is optional but if supplied is "1" followed by a "->".  All other fields except keywords are required.
#	Note that it's assumed that a 'file name' cannot be a single digit (or else we'll think
#	it's a Version number.)
#
##### VERSION 2: Each "virtual line" of the calendar is made up of one or more physical lines where a all but the last physical line of
#	a virtual line ends with a '\', implying that the next line logically follows the current line.  The order of the 
# 	fields of the virtual line is different than Version 1. It is:
#		VERSION	->	event name -> cat -> date -> distance -> unique event id -> keywords -> file name -> link 
# 	e.g.
#		2	->	2014 Spring Lake 1 Mile  ->  1	->	2014-06-23	->	1	->	1	->	\
#			Spring	->	2014 Spring Lake 1 Mile=CAT1.csv	->	\
#			https://www.clubassistant.com/c/6403675/file/competitions/SpringLake.pdf
# 	where VERSION is "2". Note the following:
#		- There is one additional field: link: this is a link to a description of this event for this year.
#		- The Version field is no longer optional (it's "2" in this case)
#		- The Keywords field is no longer optional
#		- All other fields are the same as described above except they are in a different order.
#
##### VARIATIONS:
#	- The "file name" can be one of the following strings:
#		NO RESULTS : (case sensitive) this means that there are no results available for this event yet 
#			(maybe because the event hasn't been swum yet, or the results haven't been reported, or they
#			have been reported but there are outstanding errors that prevent them from being used.
#			NOTE: the string "NO RESULTS" must match the constant named "NoResultsPath" in PMSConstants.
#		NO DETAILS : (case sensitive) means that we have no details about this event. For this reason:
#			- distance will be 0
#			- unique event id is non-empty but ignored.
#			- keywords is supplied as normal
#			- link is non-empty but ignored.
#			NO DETAILS implies NO RESULTS.
#			NOTE: the string "NO DETAILS" must match the constant $PMSConstants::NoDetailsYet
# 			This represents a placeholder for a race (or races) to be hosted by a specific host where the 
# 			exact events are yet to be determined.  For example, we might know that Spring Lake will
# 			host an open water event for cat 1 swimmers on a specific date, but we don't know the distance
# 			or any other specific information. There would likely be two such lines, one for cat 1 and one
# 			for cat 2.
#


# define static variables used during the life of execution:
my $raceOrder = 0;		# used to keep track of the order of races

sub ProcessCalendarPropertyLine($$) {
	my ($line, $yearBeingProcessed) = @_;
	my $version = 1;		# default
	#print "line='$line'\n";	
	
	# begin a new calendar line
	my @entries = split( /\s*->\s*/, $line );
	# does this line begin with a version number?
	if( $entries[0] =~ m/^\d+$/ ) {
		# yes!
		$version = $entries[0];
		shift( @entries );
	}
	my $numEntries = scalar( @entries );
	$raceOrder++;

	if( $version == 1 ) {
		# the @entries array stores these entries:
		#	$entries[0] = FileName
		#	$entries[1] = cat
		#	$entries[2] = date
		#	$entries[3] = distance
		#	$entries[4] = eventName
		#	$entries[5] = uniqueID
		#	$entries[6] = keywords or undefined
		$calendar{$raceOrder} = $entries[0];
#		$calendar{$entries[0]} = $raceOrder;
		$calendar{"$raceOrder-FileName"} = $entries[0];
		$calendar{"$raceOrder-CAT"} = $entries[1];
		$calendar{"$raceOrder-Date"} = $entries[2];
		$calendar{"$raceOrder-Distance"} = $entries[3];
		$calendar{"$raceOrder-EventName"} = $entries[4];
		$calendar{"$raceOrder-UniqueID"} = $entries[5];
		# perform some sanity checks.  Errors won't cause the program to halt - just display the error to the user.
		if( $numEntries < 6 ) {
			PMSLogging::DumpWarning( "", "", "GenerateOWResults::ProcessCalendarPropertyLine(): " .
				"Insufficient number of fields ($numEntries, should be 6 or more) in a version $version " .
				"calendar entry #$raceOrder (Line NOT ignored.)", 1 );
		}
		# get the year of this event and make sure it's the year we're processing
		# (A date is of the form "2015-05-16")
		my $eventYear = $entries[2];
		if( defined( $eventYear ) ) {
			$eventYear =~ s/-.*$//;
			if( $eventYear != $yearBeingProcessed ) {
				# oops!
				PMSLogging::DumpWarning( "", "", "PMSMacros::ProcessCalendarPropertyLine(): WARNING: Found the event " .
					"'$entries[4]' " .
					"with the date of $entries[2], but we are supposed to be processing data in the year of " .
					"'$yearBeingProcessed'.", 1 );
			}
		}
		if( 0 ) {
			PMSLogging::DumpNote( "", "", "PMSMacros::ProcessCalendarPropertyLine(): got a full calendar " .
				"line:\n", 1 );
			for( my $i = 0; $i <= $numEntries-1; $i++ ) {
				PMSLogging::DumpNote( "", "", "    $i: $entries[$i]\n", 1 );
			}
		}
	} # end of version 1
	elsif( $version == 2 ) {
		# the @entries array stores these entries:
		#	$entries[0] = eventName
		#	$entries[1] = cat
		#	$entries[2] = date
		#	$entries[3] = distance		(can be 0)
		#	$entries[4] = uniqueID
		#	$entries[5] = keywords		(may be ignored)
		#	$entries[6] = fileName		(can be "NO RESULTS" or "NO DETAILS")
		#	$entries[7] = infoLink		(may be ignored)
		$calendar{$raceOrder} = $entries[6];
#		$calendar{$entries[6]} = $raceOrder;
		$calendar{"$raceOrder-FileName"} = $entries[6];
		$calendar{"$raceOrder-CAT"} = $entries[1];
		$calendar{"$raceOrder-Date"} = $entries[2];
		$calendar{"$raceOrder-Distance"} = $entries[3];
		$calendar{"$raceOrder-EventName"} = $entries[0];
		$calendar{"$raceOrder-UniqueID"} = $entries[4];
		$calendar{"$raceOrder-Keywords"} = $entries[5];
		$calendar{"$raceOrder-Link"} = $entries[7];
		# perform some sanity checks.  Errors won't cause the program to halt - just display the error to the user.
		if( $numEntries < 8 ) {
			PMSLogging::DumpWarning( "", "", "GenerateOWResults::ProcessCalendarPropertyLine(): " .
				"Insufficient number of fields ($numEntries, should be 8) in a version $version " .
				"calendar entry #$raceOrder (Line NOT ignored.)", 1 );
		}
		# get the year of this event and make sure it's the year we're processing
		# (A date is of the form "2015-05-16")
		my $eventYear = $entries[2];
		if( defined( $eventYear ) ) {
			$eventYear =~ s/-.*$//;
			if( $eventYear != $yearBeingProcessed ) {
				# oops!
				PMSLogging::DumpWarning( "", "", "PMSMacros::ProcessCalendarPropertyLine(): WARNING: Found the event " .
					"'$entries[0]' " .
					"with the date of $entries[2], but we are supposed to be processing data in the year of " .
					"'$yearBeingProcessed'.", 1 );
			}
		}
		if( 0 ) {
			PMSLogging::DumpNote( "", "", "PMSMacros::ProcessCalendarPropertyLine(): got a full calendar " .
				"line ($numEntries entries):\n", 1 );
			for( my $i = 0; $i <= $numEntries-1; $i++ ) {
				PMSLogging::DumpNote( "", "", "    $i: $entries[$i]\n", 1 );
			}
		}
	} # end of version 2
	else {
		PMSLogging::DumpError( "", "", "GenerateOWResults::ProcessCalendarPropertyLine(): " .
			"Unknown version ($version)", 1 );
	}

} # end of ProcessCalendarPropertyLine()


#
#				PMSMacros::InsertNoResultEvent( $raceOrder );
#
# InsertNoResultEvent - invoked when processing the Calendar macro in the properties.txt file.
#	Invoked when a calendar entry defines an OW event that doesn't have any results (e.g.
#	we didn't get results yet or the event hasn't been held yet.)
#
# PASSED:
#	$raceOrder - the order of this event in the calendar of events.
#
# RETURNED:
#	n/a
#
# NOTES:
#	This routine will record the event into our database indicating that we don't have results
#	yet (no splashes, no file type)
#	This routine is used for both sanctioned events with no results and for unsanctioned events.
#
sub InsertNoResultEvent( $ ) {
	my $raceOrder = $_[0];
	my $eventName = $calendar{"$raceOrder-EventName"};
	my $fileName = $calendar{"$raceOrder-FileName"};		# should be "NO RESULTS" or "NO DETAILS" or "NO SANCTION"
	my $cat = $calendar{"$raceOrder-CAT"};
	my $date = $calendar{"$raceOrder-Date"};
	my $distance = $calendar{"$raceOrder-Distance"};		# may be zero
	my $uniqueID = $calendar{"$raceOrder-UniqueID"};		# may be 0
				
	PMS_MySqlSupport::InitialRecordThisEvent( $eventName, $fileName, $fileName, "", $cat,
		$date, $distance, $uniqueID, "", -1, -1 );

} # end of InsertNoResultEvent()






# GetCalendarValue - accessor function to give us the value of one field of one specific event.
#
# PASSED:
#	field - the field desired.  See ProcessCalendarPropertyLine() to see the different fields.
#
# RETURNED:
#	field value - a concatenation of the "race order" with the field name, in the form:
#			xxx-zzz
#		where
#			xxx is the order of the race (we count all races for the year, starting at 1)
#		and
#			zzz is the desired field.
#
# NOTES:
#	For example:
# 			my $cat = PMSMacros::GetCalendarValue( "3-CAT" );
#	will return the category of what we're calling the 3rd race of the year.
#
sub GetCalendarValue( $ ) {
	return $calendar{$_[0]};
}


# GetCalendarRef - return a reference to the %calendar hash
sub GetCalendarRef() {
	return \%calendar;
}



# 				ProcessCategoriesLine( $line );
# ProcessCategoriesLine - process a line found between a >categories and >endcategories line
#
# PASSED:
#	$line - the line to process. Of the form:
#			Trout		->		5	->	patch.jpg
#		where:
#			1st field ("Trout" above) is the category name
#			2nd field ("5" above) is the minimum number of swims for this category
#			3rd field ("patch") is the file name of the image of the patch for this category.
#				Note that this field is optional.
# RETURNED:
#	n/a
#
# NOTES:
#	Used by OWChallenge
#
my $categoryOrder = -1;
sub ProcessCategoriesLine( $ ) {
	my $line = $_[0];
	my ($name, $count, $patch) = split( /\s*->\s*/, $line );
	$patch = "" if( ! defined $patch );
	$categoryOrder++;
	my %catHash = (
		'name'	=> $name,
		'minCount'	=>	$count,
		'patch'	=>	$patch
		# we compute maxCount later
	);
	$categories[$categoryOrder] = \%catHash;
	
#	print "ProcessCategoriesLine: name=$name, count=$count\n";
} # end of ProcessCategoriesLine()


sub GetCategoryArrayRef {
	return \@categories;
}








# ProcessMacros - process all template macros in the passed line, if any.
#
# PASSED:
#	$line - the line to be processed.  May or may not contain one or more macros.
#	$lineNum - the number of the line in the template file.  Used for error messages.
#
# RETURNED:
#	$line - the passed line with all macros replaced with their values.
#
sub ProcessMacros {
	my $line = $_[0];
	my $lineNum = $_[1];
	my ($posLeft, $posRight) = 0;
	my $count = 0;
	
	while( ($posLeft != -1) && ($count < 200) )  {
		$posLeft = index( $line, "{", $posLeft );
		if( $posLeft != -1 ) {
			$count++;
		
			# If the { is immediatly followed by whitespace OR end of string we'll ignore it (support for javascript)
			if( (($posLeft+1) >= length( $line )) || (substr( $line, $posLeft+1, 1 ) =~ m/\s/ ) ) {
				$posLeft++;
				next;
			}
			
			# Aug 23, 2023: if the { is immediately preceded by a backslash (\) then remove the
			# backslash and pass the { on through with no macro processing:
			my $posPreceding = $posLeft-1;
			if( ($posPreceding >= 0) && (substr( $line, $posPreceding, 1 ) eq "\\") ) {
				substr( $line, $posPreceding, 1, "" );	
				$posLeft++;
				next;
			}
			
			$posRight = index( $line, "}", $posLeft+1 );
			if( $posRight != -1 ) {
				my $length = $posRight - $posLeft - 1;
				my $macroName = substr( $line, $posLeft+1, $length );
				my $substitute = PMSStruct::GetMacrosRef()->{$macroName};
				if( ! defined( $substitute ) ) {
					die( "!!! Error on line $lineNum in $templateName: unknown macro '$macroName'\n" );
				} else {
					$line = substr( $line, 0, $posLeft ) . $substitute . substr( $line, $posRight + 1 );
					$posLeft = 0;		# re-process the entire line for another macro
				}
			} else {
				die( "!!! Error on line $lineNum in $templateName (Probably missing '}' in template file: posRight='$posRight'): $!\n" );
			}
		}
	}
	
	if( $count >= 200 ) {
		die( "!!! Error on line $lineNum: macro expansion infinite loop (>$count)': $!\n" );
	}
	
	return $line;
} # end of ProcessMacros





#
# ValidateCalendar - Validate the calendar we read in our property file.  If something is wrong then
#	log an error.  If we discover an event we don't know about then add it to our database.
#
# NOTE:
#	If the distance is 0 then this is an entry placeholder, in which case there is no
#	real validation to be done.
#
sub ValidateCalendar() {
	
	for( my $i = 1; ; $i++ ) {
		last if( !defined $calendar{$i} );		
		my $eventName = $calendar{"$i-EventName"};
		my $eventUniqueID = $calendar{"$i-UniqueID"};
		my $category = $calendar{"$i-CAT"};
		my $eventDate = $calendar{"$i-Date"};
		my $distance = $calendar{"$i-Distance"};
		
		if( $distance == 0 ) {
			return;
		}
		
		# we have a calendar entry containing a unique event, etc.
		# do we have this event in our history?
		my $dbh = PMS_MySqlSupport::GetMySqlHandle();
		my ($sth2,$rv2) = PMS_MySqlSupport::PrepareAndExecute( $dbh,
			"SELECT EventName FROM EventHistory " .
			"WHERE UniqueEventID = '$eventUniqueID' AND " .
			"Category = '$category'" );
		if( defined(my $resultHash = $sth2->fetchrow_hashref) ) {
			# we have this UniqueEventID in our Event History - does it look like what we expect?
			#if( $eventName ne $resultHash->{'EventName'} ) {
			# 25jun2023: check to see if the event name in the database is the same as
			# same as the BEGINING of the event name in the calendar.
			
			if( $resultHash->{'EventName'} !~ m/^$eventName/i ) {
			
#			if( index( $eventName, $resultHash->{'EventName'} ) != 0 ) {
	        	PMSLogging::DumpError( "", "", "PMSMacros::ValidateCalendar(): Found an event " .
	        		"in the EventHistory with UniqueEventID='$eventUniqueID' but the name of the event in " .
	        		"the EventHistory is '" . $resultHash->{'EventName'} . "' which doesn't match the " .
	        		"name '$eventName' found in the Events table.", 1 );
			} # else we have this event in our history - go on to the next one
		} else {
			# we don't have this particular event in our event history - add it
			($sth2,$rv2) = PMS_MySqlSupport::PrepareAndExecute( $dbh,
	    		"INSERT INTO EventHistory " .
	    		"(UniqueEventID, EventName, Distance, Category) " .
	    		"VALUES (\"$eventUniqueID\", \"$eventName\", \"$distance\", \"$category\")" );
	    	my $eventHistoryId = $dbh->last_insert_id(undef, undef, "EventHistory", "EventHistoryId");
	    	if( !defined( $eventHistoryId ) ) {
	        	PMSLogging::DumpError( 0, 0, "MaintainOWSwimmerHistory::UpdateEventsHistory(): Unable to " .
	        	"INSERT into EventHistory with VALUES (\"$eventUniqueID\", \"$eventName\", \"$distance\", \"$category\")", 1 );
	    	}
		}
	} # end of for( ...
	
} # end of ValidateCalendar()

1;  # end of module

